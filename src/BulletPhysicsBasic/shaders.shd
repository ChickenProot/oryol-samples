//------------------------------------------------------------------------------
//  float/rgba8 encoding/decoding so that we can use an RGBA8
//  shadow map instead of floating point render targets which might
//  not be supported everywhere
//
//  http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
//
@code_block util
_func vec4 encodeDepth(float v) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
    return enc;
}

_func float decodeDepth(vec4 rgba) {
    return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0));
}
@end

//------------------------------------------------------------------------------
//  Shadowmap pass shaders
//
@uniform_block shadowVSParams ShadowVSParams
    mat4 mvp MVP
@end

@vs shadowVS
@use_uniform_block shadowVSParams
@in vec4 position
@out vec2 projZW
{
    _position = mul(mvp, position);
    projZW = _position.zw;
}
@end

@fs shadowFS
@highp float
@use_code_block util
@in vec2 projZW
{
    float depth = projZW.x / projZW.y;
    _color = encodeDepth(-depth);
}
@end

@program ShadowShader shadowVS shadowFS

//------------------------------------------------------------------------------
//  Color pass shaders
//
@uniform_block colorVSParams ColorVSParams
    mat4 mvp MVP
    mat4 lightMVP LightMVP
@end

@texture_block colorTextures ColorTextures
    sampler2D shadowMap ShadowMap
@end

@vs colorVS
@use_uniform_block colorVSParams
@in vec4 position
@in vec4 normal
@in vec2 texcoord0
@out vec2 uv
@out vec4 nrm
@out vec4 color
@out vec4 lightProjPos
{
    _position = mul(mvp, position);
    lightProjPos = mul(lightMVP, position);
    uv = texcoord0;
    nrm = normalize(mul(mvp, normal));
    color = vec4((normal.xyz + vec3(1.0)) * vec3(0.5), 1.0);
}
@end

@fs colorFS
@use_code_block util
@use_texture_block colorTextures
@highp float
@in vec2 uv
@in vec4 nrm
@in vec4 color
@in vec4 lightProjPos
{
    _color = color;
    vec3 lightPos = lightProjPos.xyz / lightProjPos.w;
    float smDepth = decodeDepth(tex2D(shadowMap, (lightPos.xy+1.0)*0.5));
    if (smDepth > -lightPos.z) {
        _color *= vec4(vec3(0.25), 1.0);
    }
}
@end

@program ColorShader colorVS colorFS

